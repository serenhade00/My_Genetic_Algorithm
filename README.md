# 🧬유전 알고리즘 적용 회귀분석🧬

## 개요
***
<br>

* `Genetic Algorithm` 의 정의와 목적
* 회귀 분석 및 선정 데이터 설명
* `Genetic Algorithm` 실제 구현 프로그램 분석
    * 코드 동작 방식
    * 코드 실행 결과
    * 코드 성능 분석
* 프로그램의 한계 및 개선점
* 결론

## 유전 알고리즘에 관하여
***

**유전 알고리즘(Genetic Algorithm)** 은 도대체 무엇이며, 언제 사용되는 알고리즘인가?

**정의:**

- 존 홀랜드(John Holland)에 의해서 1975년에 개발된 **전역 최적화 기법**. 
- <mark>생물체가 환경에 적응하면서 진화해가는 모습을 모방</mark>하여 **유전** 알고리즘이라고 불린다.

전역 최적화 vs 지역 최적화

<img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/global.jpg?raw=true" width="500" height ="300">

* **전역 최적화**는 다소 시간이 걸리더라도 전체 탐색영역에서 가장 좋은 해를 찾는 것을 목표로 하는 방법이다.

* **지역 최적화**는 비교적 단시간에 일부 탐색영역 내에서 가장 좋은 해를 찾는 것을 목표로 하는 방법이다. 

> 유전 알고리즘은 **전역 최적화** 기법이다.

**관련 용어:**

| 값 | 의미 |
|--- |---|
| `염색체 (chromosome)` | 하나의 해 (solution)를 표현 | 
| `유전자 (gene)` | 염색체 구성 요소, 하나의 유전 정보를 나타낸다.|  
| `자손 (offspring)` | 부모 염색체로부터 생성된 다음 세대 염색체 |  
| `적합도 (fitness)` | 염색체가 표현하는 해가 얼마나 적합한지 나타내는 값 |

**동작 방식:**

<img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/genetic.png?raw=true" width="500" height ="300">

진행 방식은 다음과 같다.

1) 초기 염색체 집합 생성
2) 초기 염색체들에 대한 적합도 계산
3) 현재 염색체들로부터 자손들을 생성
4) 생성된 자손들의 적합도 계산
5) 종료 조건 판별
- 종료 조건이 거짓인 경우, (3)으로 이동하여 반복
- 종료 조건이 참인 경우, 알고리즘을 종료

즉, **적합도를 계산하고, 자손들을 만드는 과정의 반복**이다. 적합도가 높은 개체로만 해를 구성해 나가면서, 결국 많은 세대가 반복된다면 최적해에 가까운 해를 얻어낼 수 있는것이다. 

따라서 대부분의 경우는 세대가 일정 수준 진행되거나, 해가 특정 범위에 들게되면 알고리즘을 종료한다.

알고리즘의 핵심 연산은 다음과 같다.

* 선택(selection)
    - 한 세대에서 다음 세대로 전해지는 해의 후보들을 선정한다.
    - 즉, 자손 염색체를 만들때, 어떤 부모 염색체를 가지고 만들지를 정하는 것
* 교차(crossover)
    - 선택된 해들을 교배시켜 새로운 유전자(해)를 얻는 과정
* 변이(mutation)
    - 유전자가 스스로 변이를 일이켜 임의로 다른 해로 변하는 일

각 연산마다 여러 방법이 있지만 가장 대표적인 방법들을 사용했다.

선택 연산:

<img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/roulette.png?raw=true" width="500" height ="300">

<p align="center">룰렛 휠 (Roulette Wheel)</p>

위의 그림을 보자. 

선택 연산전에는 각 해에 대한 적합도가 이미 계산된 상태이다. 그 적합도를 모두 합한뒤 각 해가 가지는 적합도를 비율을 룰렛 형태로 나타낸다. 그 후 다음 세대의 개수만큼 룰렛에서 해를 뽑아낸다. 즉, **적합도가 높을수록 선택될 확률이 높은 선택 연산**으로, *룰렛 휠 (Roulette Wheel)* 방법이라고 한다. 아무래도 좋은 해가 부모로 선택되어 자손이 나오면 좋을테니 그 의도를 가진 선택 연산이다.

교차 연산:

![sixth](https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/crossover.png?raw=true)

선택 연산으로 정해진 해를 2진수로 나타내고, 짝지어진 해끼리의 비트(bit)의 특정 부분을 교차하는 것이다. 이렇게 교차 연산 후에 나온 해들이 새로운 세대의 해가 되는것이다.

하지만 이 프로그램에서는 10진수끼리의 자리를 바꾸는 방법으로 구현했다.

변이 연산:

<img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/mutate.png?raw=true" width="500" height ="300">

지역 최적점에 빠지는 문제를 해결하기 위해 새롭게 생성된 염색체에 확률적으로 돌연변이가 발생하도록 한다. 일반적으로 0.1%, 0.05% 등의 아주 낮은 확률로 돌연변이가 발생하도록 설정한다. 

대표적으로 1) reverse 와 2) exchange 연산이 있는데(그림 오류), 여기서는 단순히 정수값을 새로운 랜덤한 값으로 설정하는 방식을 채택했다.

## 회귀 분석 및 선정 데이터 분석
***

우리는 이제 유전 알고리즘에 대해 알게되었다. 그렇다면 이제 이 최적화 기법을 이용해 과연 어떤 문제를 풀어볼지 알아보자. 그것이 바로, **회귀 분석**이다.

**회귀 분석이란?**

<img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/linear_regression.png?raw=true" width="500" height ="300">

우리는 데이터가 주어지면 어떤 형태의 패턴을 나타낼 것이라고 가정한다. 예를 들면 위 그림에서의 데이터들은 x가 증가하면 y도 증가하는 선형적인 모습을 보인다. 이런 경향을 식으로 나타내면 *y = ax+b*의 형태가 나타날 것이다.

이 때 정의한 식 *y = ax+b*를 **모형(model)** 이라고 하고, 모형의 형태를 결정짓는 변수 *a, b*를 **파라미터(parameter)** 또는 **모수(母數)** 라고한다.

즉, 회귀 분석을 한마디로 정의하면 이렇다.
> 독립변수가 종속변수에 어떤 영향을 미치는지 알기 위해 실시하는 분석방법

물론 자연에서도 그렇고 인간 사회에서도 그렇고 존재하는 데이터들이 항상 선형적인 모습만을 보이지는 않을것이다. 하지만 이번 프로젝트에서는 비교적 분석하기 쉽게 선형적인 회귀 분석만 진행한다. 

**식 적절성 판단 방법:**

식을 찾았을 때, 그 모형이 데이터에 얼마나 잘 맞는지를 측정할 방법이 필요하다. 이 때 사용하는 함수가 **손실 함수(loss function)** 라고 부르며, 모형이 데이터에 얼마나 안 맞는지 정도를 나타낸다.

<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/mse.jpg?raw=true"></p>

1. 가장 널리 쓰이는 손실 함수는 **평균 제곱 오차(*Mean Squared Error*, MSE)** 이다. 예측과 실제의 차이를 오차(error)라고 한다. 이 오차를 모두 제곱한 다음에 평균 낸 것이 MSE이다.

- 여기서 한 가지 의문이 든다. 왜 하필 제곱을 하는 것일까? 예측을 두 번 했는데 오차가 +1, -1인 경우와, 오차가 +5, -5인 경우를 생각해보자. 제곱을 하지 않고 오차의 평균을 구하면 두 경우 모두 오차의 평균은 0이 된다. 1-1도 0이고, 5-5도 0이기 때문이다. 따라서 오차 정도를 고려하기 위해 제곱을 한다. 

<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/R.jpg?raw=true"></p>

2. MSE의 단점은 크고, 작음을 직관적으로 알기 어렵다는데 있다. 예를 들어 MSE가 20이라면, 또는 100이라면 이 모형은 얼마나 적절한지 잘 와닿지 않는다. 이를 보완하는 수치가 **결정 계수(coefficient of determination)** 이다. 

- VAR은 분산을 뜻한다. (데이터와 평균의 차이를 제곱해서 평균낸 것)
- R^2은 대개 0에서 1까지 범위로 나오기 때문에 0%~100%로 읽기도 한다. 
- 보통 "이 모형은 분산의 ~%를 설명한다"라는 식으로 해석한다. 예를 들어 
R^2 = 0.7이라면 "이 모형은 분산의 70%를 설명한다"라고 해석한다.
- 분산은 데이터에 고정된 값이기 때문에 R^2은 실제로는 MSE를 정확히 반영하는 값이다. 즉, MSE가 커지면 작아지고, MSE가 작아지면 커진다. 

> 즉 유전 알고리즘에서 선택 과정 이후에 적합도를 구하는 단계가 있는데, 여기서 이 손실 함수 중 MSE를 사용해서 해의 적합도를 판단하고 교차 단계로 들어갈 것이다.

### 선정 데이터

상관관계가 있는 대용량의 데이터를 찾아보려고 노력했으나 찾기가 쉽지 않았다. 그래서 용량은 작지만 그래도 확실한 상관관계를 보이는 데이터를 기반으로 분석을 진행한다. 사실 이 부분은 좀 아쉬운 부분이긴하다.

선정한 데이터는 바로 **"고도에 따른 산에서의 온도"** 이다. 

<br>
<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/graph1.jpg?raw=true" width="500" height ="300"></p>

데이터가 20개 이하 정도의 소규모 데이터라 너무 패턴이 극단적으로 선형적이긴 하지만, 그래도 선형 회귀 모델로 쓰기에는 문제가 없기 때문에 채택하였다. 

과학적인 사실로는 지표면으로부터 멀어질수록 태양 복사열이 낮아져 온도가 감소한다는 사실이 밝혀져있다. 따라서 고도가 높아질수록, 기온이 낮아지는 상관관계를 가지고 있는 이 데이터를 가지고, 분석을 해보도록 하겠다.

## 유전 알고리즘 실제 구현 프로그램 분석
***

### **코드 분석**

`My-Genetic-Algorithm` 프로그램은 6개의 사용자 정의 함수와 main 함수로 구성했다.

사용자 정의 함수는 다음과 같다.
* `gap`, 회귀 함수의 **함수값**을 리턴, 즉 하나의 해 *a,b*를 가지고 *y=ax+b*에 대입하여 y값을 리턴한다. `selection`함수에서 **적합도(MSE)** 를 계산하기 위함이다.
* `first_gen`, 최초 해 세대를 만들기 위한 함수, 총 4가지의 해를 랜덤으로 생성
* `selection`, MSE를 각 해마다 계산하며 적합도를 계산한다. 하지만 이 MSE는 작을수록 회귀 함수의 정확도가 높은것이다. 보통 룰렛 휠 연산은 차지하는 부분이 큰 해가 선택될 확률이 높게 구현한다. 그러므로 **계산한 MSE를 MSE의 총합에서 뺀 값**을 새로운 적합도로 정의하고 룰렛 휠 연산을 돌렸다. 그래야지만 MSE가 작은 해가 높은 확률을 가지고 부모 세대로 선택되기 때문이다.
* `swap`, `crossover`함수로부터 1-2번째, 3-4번째 해끼리 짝을 지어 인자로 받는다. 그 다음 `swap`함수에서 a는 뒤의 5자리끼리를 교차시키고, b는 소수점 전체를 교차시킨다. 
* `crossover`, `swap`함수에 인자를 전달함으로써 교차 연산을 진행한다.
* `mutation`, **0.005%** 의 확률로 b의 정수 부분을 돌연변이가 나타나게 하였다.

**<u>각 코드가 어떤 기능을 가지고 무슨 역할을 수행하는지는 소스 코드에 주석을 자세하게 달아놓았으니 참조바란다.</u>**

### **실행 결과**

<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/data.jpg?raw=true" width="100" height ="250" /></p>
<p align="center">결과 1) 사용 데이터</p>

<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/regression.jpg?raw=true" width="500" height ="300" /></p>
<p align="center">결과 2) 회귀 분석 결과</p>

<p align="center"><img src = "https://github.com/serenhade00/My_Genetic_Algorithm/blob/main/img/result.jpg?raw=true" width="500" height ="300" /></p>
<p align="center">결과 3) 프로그램 실행 결과</p>


결과를 분석해보자. 

* [선형 회귀 분석 계산기](https://www.graphpad.com/quickcalcs/linear1/)를 사용하여 유전 알고리즘을 통해 추정한 모수의 적절성을 따져보았다. Best-fit-value를 살펴보면 Slope(a)값은 -0.006525+α, y절편(b)값은 15.25±0.3325로 나온다. 과연 이 값에 얼마나 근접한 값으로 접근하는지 살펴보자.

* 첫번째 줄에 있는 결과가 `first_gen()`을 통한 초기 세대 4개의 해이다. 회귀 분석이 지역 최적점에 빠지지 않게 하기 위해 초기에 특정 범위를 지정해주었다. 기울기인 *a*는 고도 -24-15/6000-0 = 0.0067...이 나오기에 0~-0.01의 사이의 값을 갖도록 했고, y 절편인 *b*는 10에서 20사이의 값을 가지도록 했다. 어차피 적합도를 제곱의 형태인 MSE를 가지고 하기 때문에 이 정도 범위만 주어도 충분히 결과가 왔다갔다 할 것이다. 
* 순서대로 5세대를 거치며 각각 선택, 교차, 변이 연산을 거친 결과인데, 초기 세대에서 가장 해에 가까운 것은 1,2번째의 해이다. a와 b값이 거의 회귀 분석을 통한 값과 가깝기 때문이다. 
* 1세대 선택 과정에서부터 이미 가장 최적해와 거리가 먼 4번째 해는 선택되지 못했다. 룰렛 휠 연산에 의해 아마 낮은 확률을 가졌기에 탈락되었을 것이다. 
* 그 후 4세대 선택 과정을 보면 초기 세대에서 3번째로 해와 가까웠던 해가 탈락했다. 그 이후로는 동일한 해끼리 교차 연산과 선택 과정이 일어나며 해와 가장 가까운 세대만이 살아남았다.
* 정상적으로 선택, 교차 연산이 일어나고, 변이 연산은 낮은 확률 때문에 이 예제에서는 확인되지 않았다.

### **성능 분석**

* 시간복잡도
    * `first_gen`, 은 단순히 해의 개수만큼 랜덤으로 할당하므로 O(n)
    * `selection`, MSE를 각 해마다 계산하며 적합도를 계산한다. 각 해마다 MSE를 계산하므로 이중 루프롤 돈다. 따라서 O(n^2).
    * `swap,crossover`는 두개씩 짝 지어서 단순히 자리 교환만 하므로 O(n) 
    * `mutation` 역시 루프를 한번만 돌며 확률을 뚫으면 변이가 나타나므로 O(n).

* 기타 참고할 점
    * 원래 보통의 유전 알고리즘 구현보다 더 실행 시간이 들 것이다. 왜냐하면 물론 문제마다 상황이 다르겠지만 선택 과정에서 룰렛 휠에 MSE를 이용하여 확률을 할당할 때 낮은 순서대로 높은 우선순위를 가져야 했으므로 총합-MSE값을 새로 계산해서 할당했기 때문이다.
    * 또한, 교차 연산에서는 보통 해를 2진수로 표현하여 비트끼리 교환하는 과정을 거치는데, 이 프로그램은 그냥 10진수로 표현된 소수 부분의 특정 부분을 교환하는 식으로 구현했다. 이건 아마 2진수로 변환하고 비트를 체인지하고 다시 2진수로 변환하는 원래 방법보다는 빠를 수 있다.
    * 변이 연산은 애초에 일어날 확률이 적은데 함수는 항상 실행되므로 아무래도 불필요한 연산이 소요되기는 한다.

## 한계 및 개선점
***

- 이 프로그램은 다소 정적인면이 존재한다. 이미 알고리즘을 실행할 때 어느정도의 범위를 가정하고 시작하기 때문이다. 정말 비교적 분석이 쉬운 **선형 회귀 분석**에서만 통하는 방법일수도 있다.

- 교차 연산에서 임의로 *a*는 뒤의 5자리, *b*는 소수점 전체를 바꾸도록 설정하고, 또한 1-2 / 3-4 끼리만 바꾸도록 설정을 해놨다. 물론 세대를 거칠수록 조금씩이라도 최적해에 다가가겠지만 과연 얼마나 빠르게 진행시켜줄지 수학적인 의구심이 든다.

- 또한 해의 개수와 데이터의 개수를 너무 적게 잡은 것 같아 너무 아쉽다. 이미 거의 선형적인 모습이 보일정도로 너무나도 직관적인 데이터이고, 해의 개수가 적다보니 같은 해가 선택되면 그 해끼리 교차 연산을 해봤자 아무 의미가 없어지는 사태가 발생했다. 

## 결론
***

- **유전 알고리즘**은 이론적으로 전역 최적점을 찾을 수 있으며, 수학적으로 명확하게 정의되지 않은 문제에도 적용할 수 있기 때문에 매우 유용하게 이용된다. 일반적으로 유전 알고리즘에 대해 알고리즘이라는 표현을 쓰긴 하나, 이는 특정한 문제를 풀기 위한 알고리즘이라기 보다는 최적화 문제를 풀기 위한 방법론에 가깝다. 

- 즉, 모든 문제에 적용 가능한 하나의 알고리즘이나 소스 코드가 있는 것이 아니기 때문에 유전 알고리즘의 원리를 이해하고, 이를 본인이 원하는 문제에 적용하는 것이 중요하다.

- 이 알고리즘을 배우면서 느낀점은, **'데이터를 다음 세대에 유전시키는것'** 만 같지 문제마다 구현 방법은 천차만별임을 알 수 있었다. 선택 방법은 뭐로 하는지, 교차를 어떻게 하는지, 적합도를 어떻게 계산하는지 등에 따라 수 많은 경우의 수가 나온다는걸 깨달았다. 

- 이 프로그램이 완벽한 프로그램은 절대 아니지만, 그래도 주요 연산을 직접 구현해보면서 가까운 해를 찾아나가는 방식은 잘 동작하기에 만족스럽다.

<p align="center">Copyrightⓒ. 2022. By Seonghwan Shin. </p>
<p align="center">All Rights Reserved.</p>
<p align="center">-The End-</p>